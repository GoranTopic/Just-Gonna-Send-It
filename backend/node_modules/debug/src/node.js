  else if (val === 'null') val = null;
  // For supporting legacy API we put the FD here.
      return str.trim()
      }
      }
    var c = this.color;
 * Save `namespaces`.
        writable: true
      stream = new tty.WriteStream(fd);
 * Map %o to `util.inspect()`, all on a single line.
      stream._type = 'tty';
  return process.env.DEBUG;
 * The file descriptor to write the `debug()` calls to.
function log() {
        stream._handle.unref();
        stream._handle.unref();
      stream._type = 'fs';
  return stream;
  return /^debug_/i.test(key);
      var net = require('net');
if (1 !== fd && 2 !== fd) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    case 'PIPE':
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
 * This is the Node.js implementation of `debug()`.
      });
 * Expose `debug()` as the module.
  if (null == namespaces) {
var stream = 1 === fd ? process.stdout :
  return 'colors' in exports.inspectOpts
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
function useColors() {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
  stream.fd = fd;
  var useColors = this.useColors;
        readable: false,
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
    case 'TCP':
      throw new Error('Implement me. Unknown stream file type!');
      // Probably an error on in uv_guess_handle()
 * @return {String} returns the previously persisted debug modes
exports.formatArgs = formatArgs;
exports.log = log;
      // stream from an existing fd which is writable only. But for now
function save(namespaces) {
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });
  var keys = Object.keys(exports.inspectOpts);
exports.formatters.o = function(v) {
exports = module.exports = require('./debug');
    process.env.DEBUG = namespaces;
    // string 'null' or 'undefined'. Just delete instead.
 * Init logic for `debug` instances.
  for (var i = 0; i < keys.length; i++) {
}
}
}
}
}
}
}
}
}, {});
      break;
      break;
      break;
      // Test: ./node test/fixtures/echo.js < /etc/passwd
function formatArgs(args) {
  else val = Number(val);
 *   $ DEBUG_FD=3 node script.js 3>debug.log
  // coerce string value into JS value
  var name = this.namespace;
    args[0] = new Date().toUTCString()
 * Build up the default `inspectOpts` object from the environment variables.
      // FIXME Should probably have an option in net.Socket to create a
      + ' ' + name + ' ' + args[0];
      // See https://github.com/joyent/node/issues/1726
      // See https://github.com/joyent/node/issues/1726
      stream.read = null;
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
  obj[prop] = val;
  }
  }
  }
  }
  return stream.write(util.format.apply(util, arguments) + '\n');
      // FIXME Hack to have stream not keep the event loop alive.
exports.enable(load());
 * Adds ANSI color escape codes if enabled.
exports.formatters.O = function(v) {
exports.save = save;
    // If you set a process.env field to null or undefined, it gets cast to the
      stream._type = 'pipe';
    case 'TTY':
  stream._isStdio = true;
 * differently for a particular `debug` instance.
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';
  // camel-case
      stream = new net.Socket({
    delete process.env.DEBUG;
  debug.inspectOpts = {};
function createWritableStdioStream (fd) {
    ? Boolean(exports.inspectOpts.colors)
}).reduce(function (obj, key) {
    .substring(6)
exports.init = init;
      var fs = require('fs');
exports.load = load;
 * Create a new `inspectOpts` object in case `useColors` is set
 * @param {String} namespaces
  var tty_wrap = process.binding('tty_wrap');
function init (debug) {
 * @api private
 * @api private
  switch (tty_wrap.guessHandleType(fd)) {
  return obj;
var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  } else {
  } else {
             2 === fd ? process.stderr :
  this.inspectOpts.colors = this.useColors;
  this.inspectOpts.colors = this.useColors;
exports.inspectOpts = Object.keys(process.env).filter(function (key) {
 *
 *
 *
 *
 *
 *
 *
 *
 * Module dependencies.
};
};
      if (stream._handle && stream._handle.unref) {
      if (stream._handle && stream._handle.unref) {
  if (useColors) {
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
 */
  var stream;
    case 'FILE':
             createWritableStdioStream(fd);
var tty = require('tty');
  var prop = key
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
      stream.readable = false;
      // Hack to have stream not keep the event loop alive.
 * Copied from `node/src/node.js`.
 * Enable namespaces listed in `process.env.DEBUG` initially.
 * Is stdout a TTY? Colored output is enabled when `true`.
      // we'll just add this hack and set the `readable` member to false.
  var val = process.env[key];
 * Load `namespaces`.
var util = require('util');
  return util.inspect(v, this.inspectOpts)
exports.colors = [6, 2, 3, 4, 5, 1];
 * Colors.
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');















































  return util.inspect(v, this.inspectOpts);
    .toLowerCase()
function load() {
    : tty.isatty(fd);
    .split('\n').map(function(str) {
exports.useColors = useColors;
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
  // Note stream._type is used for test-module-load-list.js
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
    default:
    }).join(' ');
 * @api public
    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        fd: fd,
